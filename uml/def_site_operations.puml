@startuml
title Flujo de site_operation(ACTIONS, driver, timeout, download_folder, data_access)

skinparam activity {
  BackgroundColor #fefefe
  BarColor #999999
  BorderColor #333333
  ArrowColor #333333
}

partition "Navegación & Automatización" {
start
repeat
  :Para cada (url, steps) en ACTIONS.items();
  :print("Navegando a " + url);
  :driver.get(url);

  repeat
    :Obtener step = steps[idx];\n typ = step["type"];
    if (typ == "wait_user"?) then (sí)
      :msg = step.get("value", "Presiona enter...");\nprint("⏸ " + msg);
      :input();
    else (no)
      :by = step["by"]; loc = step["locator"];
      :print("Paso " + idx + ": " + typ + " en " + loc);
      if (Elemento clickable antes de timeout?) then (sí)
        if (typ == "click"?) then (click)
          :elem.click();\nprint("✓ Clicked " + loc);
        elseif (typ == "send_keys"?) then (keys)
          :elem.click();\n:elem.clear();\n:elem.send_keys(step["value"]);
          :print("✓ Sent keys a " + loc);
        else (otro)
          :print("Tipo desconocido: " + typ);
        endif
      else (timeout)
        :print("✗ Timeout en paso " + idx + " (" + typ + " @ " + loc + ")");
        note right
        En código real: se capturaría
        TimeoutException y se continua
        con la siguiente URL.
        end note
      endif
    endif
    :idx = idx + 1;
  repeat while (idx ≤ len(steps))
repeat while (quedan más url?)
:input("Presiona enter para cerrar el navegador");
:driver.quit();
}

partition "Preparación & Lectura de cabeceras" {
:print("Renombrando y fusionando archivos descargados...");
:working_folder = abspath(join(download_folder, ".."));
:headers_credit = data_access["BANORTE_credit_headers"];
:headers_debit  = data_access["BANORTE_debit_headers"];
:headers_MFI    = data_access["BANORTE_month_free_headers"];
:dict_files = {};
:csv_files = glob(join(download_folder, "*.csv"));
}

partition "Categorización de CSV" {
repeat
  :Para cada file en csv_files;
  :dt = fromtimestamp(getmtime(file));\ninfo = {y,m,d};
  :Leer encabezados (utf-8 / latin1 fallback);
  if (headers == credit?) then (credit)
    :info["type"] = "credit";
  elseif (headers == debit?) then (debit)
    :info["type"] = "debit";
  elseif (headers == MFI?) then (MFI)
    :info["type"] = "MFI";
  else (ninguno)
    :print("⚠️ No coincide: " + basename(file));
    --> continuar;
  endif
  :dict_files[file] = info;
repeat while (quedan más archivos)
:print("📁 Archivos categorizados... (listar)");
}

partition "Agrupar, fusionar y guardar" {
:grouped_files = defaultdict(list);\nAgregar cada file por (y,m,d,type);
repeat
  :Para cada grupo (y,m,d,t) -> file_list;
  :print("Fusionando grupo " + y+"-"+m+"-"+d+" "+t);
  :dataframes = [];\nloaded_hashes = set();

  repeat
    :Para cada each_file en file_list;
    :Leer CSV (utf-8 / latin1);
    :df_hash = hash_pandas_object(df).sum();
    if (df_hash en loaded_hashes?) then (sí)
      :print("⚠️ Duplicado: " + basename(each_file));
    else (no)
      :loaded_hashes.add(df_hash);\n:dataframes.append(df);
    endif
  repeat while (quedan más files)

  if (dataframes vacío?) then (sí)
    :print("⚠️ Sin válidos para grupo");
    --> siguiente grupo;
  endif

  :final_df = concat(dataframes, ignore_index=True);
  :csv_folder = join(working_folder, f"{y}-{m:02d}");
  if (csv_folder no existe?) then (crear)
    :create_directory_if_not_exists(csv_folder);
  endif
  :csv_path = join(csv_folder, f"{y}-{m:02d}-{d:02d}_{t}.csv");
  :final_df.to_csv(csv_path, index=False);
  :print("✅ Movido: " + basename(csv_path));
repeat while (quedan más grupos)
}

partition "Limpieza & Mensaje final" {
:Para cada (f, _) en dict_files: print("🗑️ Eliminando " + basename(f));\n os.remove(f);
:print("Fin. Continúa con la opción 2 (procesar CSV por carpeta)");
stop
}

@enduml